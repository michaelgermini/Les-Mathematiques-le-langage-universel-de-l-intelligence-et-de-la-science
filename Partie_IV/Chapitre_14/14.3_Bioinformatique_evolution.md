# 14.3. Bioinformatique et évolution

## Introduction

La bioinformatique applique les méthodes mathématiques et informatiques à l'analyse des données biologiques. De l'alignement de séquences à la reconstruction phylogénétique, en passant par la prédiction de structure des protéines, ce domaine est au cœur de la biologie moderne. Ce chapitre présente les fondements algorithmiques et les modèles mathématiques de l'évolution moléculaire.

---

## 1. Alignement de séquences

### 1.1 Problème fondamental

#### Objectif
Trouver la meilleure correspondance entre deux (ou plusieurs) séquences biologiques (ADN, ARN, protéines).

#### Exemple
```
Séquence 1: A C G T A C G T
Séquence 2: A C - T A G G T
            | |   | | . | |
Score:      +1+1-2+1+1-1+1+1 = 3
```

### 1.2 Alignement global (Needleman-Wunsch)

#### Programmation dynamique
Matrice F[i,j] = meilleur score pour aligner les i premiers caractères de S₁ avec les j premiers de S₂.

#### Récurrence
```
F[i,j] = max {
    F[i-1,j-1] + s(S₁[i], S₂[j])    (match/mismatch)
    F[i-1,j] + g                      (gap dans S₂)
    F[i,j-1] + g                      (gap dans S₁)
}
```
où s(a,b) est le score de substitution et g la pénalité de gap.

#### Complexité
- Temps : O(mn)
- Espace : O(mn), réductible à O(min(m,n)) avec Hirschberg

### 1.3 Alignement local (Smith-Waterman)

#### Différence avec global
- Initialisation : F[i,0] = F[0,j] = 0
- Récurrence : ajouter 0 comme option (redémarrer l'alignement)
- Résultat : maximum de toute la matrice

#### Application
Trouver des régions similaires dans des séquences globalement différentes.

### 1.4 BLAST (Basic Local Alignment Search Tool)

#### Principe heuristique
1. **Seeding** : trouver des mots courts (k-mers) communs
2. **Extension** : étendre les hits sans gap
3. **Évaluation** : calculer la significativité statistique

#### E-value
Nombre attendu d'alignements de score ≥ S par hasard :
```
E = K × m × n × e^{-λS}
```
où K et λ dépendent de la matrice de score et de la composition.

### 1.5 Matrices de substitution

#### BLOSUM (BLOcks SUbstitution Matrix)
Dérivées de blocs de séquences alignées.
- **BLOSUM62** : séquences à 62% d'identité (standard)
- **BLOSUM80** : séquences proches
- **BLOSUM45** : séquences divergentes

#### PAM (Point Accepted Mutation)
Basées sur des modèles évolutifs.
- **PAM1** : 1% de divergence
- **PAM250** : séquences très divergentes

---

## 2. Phylogénie moléculaire

### 2.1 Arbres phylogénétiques

#### Représentation
```
        ┌── Espèce A
    ┌───┤
    │   └── Espèce B
────┤
    │   ┌── Espèce C
    └───┤
        └── Espèce D
```

#### Types d'arbres
- **Enraciné** : ancêtre commun identifié
- **Non enraciné** : relations sans direction temporelle
- **Cladogramme** : topologie seule
- **Phylogramme** : longueurs de branches proportionnelles aux distances

### 2.2 Méthodes de distance

#### Matrice de distances
Calculer d(i,j) pour toutes les paires de séquences.

#### UPGMA (Unweighted Pair Group Method with Arithmetic Mean)
1. Trouver la paire (i,j) de distance minimale
2. Créer un nœud parent à distance d(i,j)/2
3. Mettre à jour les distances
4. Répéter

Suppose une horloge moléculaire (taux d'évolution constant).

#### Neighbor-Joining
Plus flexible, ne suppose pas d'horloge moléculaire.
Minimise la longueur totale de l'arbre.

### 2.3 Maximum de parcimonie

#### Principe
L'arbre optimal est celui qui minimise le nombre de changements évolutifs.

#### Algorithme de Fitch
Pour un arbre donné, calculer le score de parcimonie en O(n×L).

#### Recherche d'arbre
- Espace des arbres : (2n-3)!! pour n espèces
- Heuristiques : NNI, SPR, TBR

### 2.4 Maximum de vraisemblance

#### Modèle de substitution
Probabilité de passer de nucléotide i à j en temps t :
```
P(j|i,t) = [e^{Qt}]ᵢⱼ
```
où Q est la matrice de taux.

#### Modèles courants

| Modèle | Paramètres | Description |
|--------|------------|-------------|
| **JC69** | 1 | Tous les taux égaux |
| **K80** | 2 | Transitions ≠ transversions |
| **HKY85** | 5 | + fréquences inégales |
| **GTR** | 9 | Général réversible |

#### Vraisemblance
```
L(T,θ) = P(D|T,θ) = ∏_sites P(site|T,θ)
```
Calculée par l'algorithme de Felsenstein (pruning).

### 2.5 Inférence bayésienne

#### Posterior sur les arbres
```
P(T|D) ∝ P(D|T) × P(T)
```

#### MCMC (Markov Chain Monte Carlo)
- Explore l'espace des arbres
- Échantillonne selon la distribution postérieure
- Permet de quantifier l'incertitude

#### Logiciels
- **MrBayes** : inférence bayésienne
- **BEAST** : datation moléculaire
- **RAxML**, **IQ-TREE** : maximum de vraisemblance

---

## 3. Modèles d'évolution moléculaire

### 3.1 Théorie neutraliste (Kimura)

#### Hypothèse
La plupart des substitutions sont neutres (ni avantageuses ni délétères).

#### Taux de substitution
```
k = μ (taux de mutation)
```
pour les mutations neutres.

#### Horloge moléculaire
Si k est constant, le nombre de différences est proportionnel au temps de divergence.

### 3.2 Sélection

#### Types de sélection

| Type | Effet | Signature (dN/dS) |
|------|-------|-------------------|
| **Purifiante** | Élimine les délétères | ω < 1 |
| **Neutre** | Pas d'effet | ω = 1 |
| **Positive** | Favorise les avantageux | ω > 1 |

où dN = substitutions non-synonymes, dS = synonymes.

#### Détection de sélection positive
- Tests de branche (PAML)
- Tests de site
- McDonald-Kreitman

### 3.3 Coalescence

#### Principe
Modélise la généalogie des allèles en remontant le temps.

#### Temps de coalescence
Pour n lignées dans une population de taille N :
```
E[T_n] = 2N / (n(n-1)/2)
```

#### Applications
- Estimation de la taille de population
- Détection de sélection
- Inférence démographique

### 3.4 Génétique des populations

#### Équilibre de Hardy-Weinberg
En l'absence de forces évolutives :
```
p² + 2pq + q² = 1
```
où p, q sont les fréquences alléliques.

#### Forces évolutives
- **Mutation** : crée de la variation
- **Sélection** : change les fréquences
- **Dérive** : fluctuations aléatoires
- **Migration** : flux de gènes

---

## 4. Prédiction de structure

### 4.1 Problème du repliement des protéines

#### Défi
Prédire la structure 3D d'une protéine à partir de sa séquence d'acides aminés.

#### Niveaux de structure
- **Primaire** : séquence
- **Secondaire** : hélices α, feuillets β
- **Tertiaire** : repliement 3D complet
- **Quaternaire** : assemblage de sous-unités

### 4.2 Méthodes classiques

#### Homology modeling
Si une protéine homologue de structure connue existe :
1. Aligner les séquences
2. Construire un modèle basé sur le template
3. Raffiner

#### Ab initio / De novo
Sans template :
- Échantillonnage de conformations
- Fonctions d'énergie
- Très difficile pour grandes protéines

### 4.3 AlphaFold et la révolution IA

#### Architecture
- Input : séquence + alignement multiple (MSA)
- Attention sur les paires de résidus
- Prédiction des distances et angles
- Raffinement itératif

#### Performance
- CASP14 (2020) : précision proche de l'expérimental
- AlphaFold DB : structures prédites pour ~200M de protéines

#### Impact
- Accélère la recherche en biologie structurale
- Aide à la conception de médicaments
- Compréhension des mécanismes moléculaires

### 4.4 Prédiction de structure d'ARN

#### Défis spécifiques
- Appariements de bases non canoniques
- Structures tertiaires complexes
- Moins de données que pour les protéines

#### Méthodes
- Minimisation d'énergie libre
- Méthodes comparatives
- Deep learning émergent

---

## 5. Réseaux biologiques

### 5.1 Types de réseaux

| Réseau | Nœuds | Arêtes |
|--------|-------|--------|
| **PPI** | Protéines | Interactions physiques |
| **Régulation** | Gènes | Régulation transcriptionnelle |
| **Métabolique** | Métabolites | Réactions enzymatiques |
| **Signalisation** | Protéines | Cascades de signaux |

### 5.2 Propriétés topologiques

#### Mesures
- **Degré** : nombre de connexions
- **Clustering** : densité locale
- **Centralité** : importance dans le réseau
- **Modularité** : structure en communautés

#### Observations
- **Scale-free** : distribution des degrés en loi de puissance
- **Small-world** : diamètre faible
- **Hubs** : nœuds essentiels (souvent gènes essentiels)

### 5.3 Inférence de réseaux

#### À partir de données d'expression
- Corrélation / information mutuelle
- Réseaux bayésiens
- Méthodes de régression (GENIE3)

#### Intégration de données multiples
- Combiner PPI, expression, phylogénie
- Méthodes de kernel
- Graph neural networks

### 5.4 Analyse fonctionnelle

#### Enrichissement
Tester si un ensemble de gènes est enrichi pour certaines fonctions.
- Gene Ontology (GO)
- KEGG pathways
- Test hypergéométrique

#### Modules fonctionnels
Identifier des groupes de gènes co-régulés ou co-exprimés.

---

## 6. Big data en génomique

### 6.1 Séquençage haut débit

#### Technologies
| Génération | Technologie | Longueur | Débit |
|------------|-------------|----------|-------|
| **2ème** | Illumina | 150-300 bp | Très haut |
| **3ème** | PacBio, Nanopore | 10-100 kb | Moyen |

#### Applications
- Séquençage de génomes
- RNA-seq (transcriptome)
- ChIP-seq (épigénome)
- Single-cell sequencing

### 6.2 Défis computationnels

- **Volume** : pétaoctets de données
- **Vitesse** : analyse en temps réel
- **Alignement** : milliards de reads
- **Variant calling** : millions de variants

### 6.3 Outils et pipelines

| Tâche | Outils |
|-------|--------|
| **Alignement** | BWA, Bowtie2, STAR |
| **Variant calling** | GATK, DeepVariant |
| **RNA-seq** | Salmon, DESeq2 |
| **Single-cell** | Seurat, Scanpy |
| **Assemblage** | SPAdes, Canu |

---

## Conclusion

La bioinformatique et la biologie évolutive computationnelle sont devenues indispensables pour :

1. **Analyser** les séquences génomiques (alignement, annotation)
2. **Reconstruire** l'histoire évolutive (phylogénie, datation)
3. **Prédire** les structures et fonctions (AlphaFold, réseaux)
4. **Intégrer** les données massives (omiques, single-cell)

Ces outils mathématiques et informatiques transforment notre compréhension du vivant, de l'évolution moléculaire à la médecine personnalisée.
